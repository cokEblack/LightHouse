package breakout.game.gameobject;

import breakout.game.api.GameObject;
import breakout.game.texture.ImageTexture;
import breakout.game.texture.Texture;
import breakout.util.Builder;
import breakout.util.GenericNamingStrategy;
import breakout.util.NamingStrategy;
import newton.geometry.Circle;
import newton.geometry.Point;
import newton.geometry.Rectangle;
import newton.geometry.Vector;
import newton.physics.Body;

import java.awt.image.BufferedImage;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * The {@code GameObjectBuilder} provides a fluent interface to construct {@code GameObject}s.
 *
 * A {@code GameObjectBuilder} can be used as a factory. Each method, that returns
 * an important object used to construct the final {@code GameObject}, must be created
 * by a {@code Supplier}. This guarantees that every object created by this builder
 * does not share a common state.
 *
 * By default this classes uses a {@code GenericNamingStrategy}.
 *
 * @author Melf Kammholz
 * @author Sebastian Regenstein
 *
 */
public class GameObjectBuilder<T extends GameObject> implements Builder<GameObject> {

    /** The type of the game object that is going to be constructed by this builder */
    private Class<?> gameObjectClass;

    /** The naming strategy used by this builder to dynamically generate names */
    private NamingStrategy namingStrategy;

    /** A health supplier */
    private Supplier<Health> healthSupplier;

    /** A body supplier */
    private Supplier<Body> bodySupplier;

    /** Whether the game objects are going to ignore gravity or not */
    private boolean isGravityIgnored = false;

    /**
     * The velocity of the game objects
     *
     * The current velocity does not need a supplier because a vector
     * is immutable.
     *
     */
    private Vector currentVelocity = new Vector(0, 0);

    /**
     * The maximum velocity of the game objects
     *
     * The maximum velocity does not need a supplier because a vector
     * is immutable.
     *
     */
    private Vector maximumVelocity = new Vector(0, 0);

    /** A texture supplier */
    private Supplier<Texture> textureSupplier;

    /**
     * Creates a builder with a type.
     *
     * This builder can only construct game object of the provided type.
     *
     * @param gameObjectClass The type of the game object
     *
     */
    public GameObjectBuilder(Class<? extends GameObject> gameObjectClass) {

        if (gameObjectClass == null) {
            throw new IllegalArgumentException("A type must be provided for the construction of the game objects.");
        }

        this.gameObjectClass = gameObjectClass;
        namingStrategy = new GenericNamingStrategy(gameObjectClass.getSimpleName());
    }

    /**
     * Creates a builder with a type.
     *
     * This method can be used to immediately chain the method calls.
     *
     * @param gameObjectClass The type of the game object
     * @return A builder which can build object of the provided type
     *
     */
    public static GameObjectBuilder create(Class<? extends GameObject> gameObjectClass) {
        return new GameObjectBuilder(gameObjectClass);
    }

    /**
     * Sets the naming strategy of this builder.
     *
     * @param namingStrategy A naming strategy
     */
    public void setNamingStrategy(NamingStrategy namingStrategy) {
        this.namingStrategy = namingStrategy;
    }

    /**
     * Sets the name for each {@code GameObject}.
     *
     * Each {@code GameObject} created by this builder is going to share
     * the same name, if this method is used to set a name.
     *
     * @param name A name
     */
    public GameObjectBuilder<T> setName(String name) {
        // TODO find an adequate name for a naming strategy that always returns the same name
        namingStrategy = () -> name;
        return this;
    }

    /**
     * Returns a name generated by the naming strategy.
     *
     * @return A name
     */
    public String getName() {
        return namingStrategy.createName();
    }

    /**
     * Tells the builder to use rectangular bodies of a set width, height and
     * mass.
     *
     * TODO refactor remove position
     *
     * @param x A x-coordinate
     * @param y A y-coordinate
     * @param width The width of the rectangular body
     * @param height The height of the rectangular body
     * @param mass The mass of body
     * @return The builder
     */
    public GameObjectBuilder<T> useRectangularBody(float x, float y, float width, float height, float mass) {
        bodySupplier = () -> new Body(new Rectangle(x, y, width, height), mass);
        return this;
    }

    /**
     * Tells the builder to use circular bodies of a set radius and mass.
     *
     * TODO refactor remove position
     *
     * @param x A x-coordinate
     * @param y A y-coordinate
     * @param radius The radius of the circular body
     * @param mass The mass of body
     * @return The builder
     */
    public GameObjectBuilder<T> useCircularBody(float x, float y, float radius, float mass) {
        bodySupplier = () -> new Body(new Circle(x, y, radius), mass);
        return this;
    }

    /**
     * Tells the builder to build game objects that ignore or do not ignore
     * gravity.
     *
     * @param isGravityIgnored Whether gravity is ignored or not
     * @return The builder
     */
    public GameObjectBuilder<T> ignoreGravity(boolean isGravityIgnored) {
        this.isGravityIgnored = isGravityIgnored;
        return this;
    }

    /**
     * Returns {@code true} if gravity is ignored, else this method returns
     * {@code false}.
     *
     * @return Whether gravity is ignored or not.
     */
    public boolean isGravityIgnored() {
        return isGravityIgnored;
    }

    /**
     * Returns a new body.
     *
     * @return A new body
     */
    public Body getBody() {
        return bodySupplier.get();
    }

    /**
     * Sets the current velocity of the game objects.
     *
     * @param velocity The current velocity
     * @return The builder
     */
    public GameObjectBuilder<T> setCurrentVelocity(Point velocity) {
        currentVelocity = new Vector(velocity);
        return this;
    }

    /**
     * Sets the current velocity of the game objects.
     *
     * @param vx The current velocity in x-direction
     * @param vy The current velocity in y-direction
     * @return The builder
     */
    public GameObjectBuilder<T> setCurrentVelocity(float vx, float vy) {
        return setCurrentVelocity(new Vector(vx, vy));
    }

    /**
     * Returns the current velocity that is used to build the game objects.
     *
     * @return The current velocity
     */
    public Vector getCurrentVelocity() {
        return currentVelocity;
    }

    /**
     * Sets the maximum velocity of the game objects.
     *
     * @param velocity The maximum velocity
     * @return The builder
     */
    public GameObjectBuilder<T> setMaximumVelocity(Point velocity) {
        maximumVelocity = new Vector(velocity);
        return this;
    }

    /**
     * Sets the maximum velocity of the game objects.
     *
     * @param vx The maximum velocity in x-direction
     * @param vy The maximum velocity in y-direction
     * @return The builder
     */
    public GameObjectBuilder<T> setMaximumVelocity(float vx, float vy) {
        maximumVelocity = new Vector(vx, vy);
        return this;
    }

    /**
     * Returns the maximum velocity that is used to build the game objects.
     *
     * @return The maximum velocity
     */
    public Vector getMaximumVelocity() {
        return maximumVelocity;
    }

    /**
     * Sets the texture supplier for this builder.
     *
     * @param textureSupplier A texture supplier
     * @return The builder
     */
    public GameObjectBuilder<T> withTextureSupplier(Supplier<Texture> textureSupplier) {
        this.textureSupplier = textureSupplier;
        return this;
    }

    /**
     * Sets the texture supplier for this builder.
     *
     * The {@code drawImage} consumer is used to draw the provided image. This
     * method excepts the body supplier to be already set as this method uses
     * the boundary of the body to construct the image.
     *
     * Note that this method disposes the {@code Graphics} context.
     *
     * @param drawImage A consumer which manipulate the provided image
     * @return The builder
     */
    public GameObjectBuilder<T> withTextureSupplier(Consumer<BufferedImage> drawImage) {

        if (bodySupplier == null) {
            throw new IllegalStateException("To use this method properly, tell the builder which Body to use.");
        }

        Body body = bodySupplier.get();

        BufferedImage image = new BufferedImage((int) body.getWidth(), (int) body.getHeight(), BufferedImage.TYPE_4BYTE_ABGR);
        drawImage.accept(image);
        image.getGraphics().dispose();

        return withTextureSupplier(() -> new ImageTexture(image));

    }

    /**
     * Creates a new texture.
     *
     * @return A new texture
     */
    public Texture getTexture() {
        return textureSupplier.get();
    }


    /**
     * Tells the builder to create game objects with full health and a set
     * health regeneration rate.
     *
     * @param maximumHealth The maximum health of the game objects
     * @param regenerationRate The health regeneration rate of the game objects
     * @return The builder
     */
    public GameObjectBuilder<T> withFullHealth(float maximumHealth, float regenerationRate) {

        // This method ensures that any GameObject constructed by this builder has
        // an individual health object.
        healthSupplier = () -> new Health(maximumHealth, maximumHealth, regenerationRate);

        return this;

    }

    /**
     * Tells the builder to create game objects with full health and the
     * regeneration rate set to 0.
     *
     * @param maximumHealth The maximum health of the game objects
     * @return The builder
     */
    public GameObjectBuilder<T> withFullHealth(float maximumHealth) {
        return withFullHealth(maximumHealth, 0);
    }

    /**
     * Creates a new {@code Health} object.
     *
     * @return A new {@code Health} object
     */
    public Health getHealth() {
        return healthSupplier.get();
    }

    @Override
    public T build() throws InstantiationException {

        T gameObject = null;

        try {
            gameObject = (T) gameObjectClass.getDeclaredConstructor(GameObjectBuilder.class).newInstance(this);
        } catch (ReflectiveOperationException exception) {
            throw new InstantiationException("Any GameObject class must implement a constructor which takes a GameObjectBuilder as its only parameter.");
        }

        return gameObject;

    }

}
